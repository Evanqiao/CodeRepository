#!@pathpython@
# Copyright (c) 2006-2007 Intel Corporation
# All rights reserved.
#
# This file is distributed under the terms in the attached INTEL-LICENSE     
# file. If you do not find these files, copies can be found by writing to
# Intel Research Berkeley, 2150 Shattuck Avenue, Suite 1300, Berkeley, CA, 
# 94704.  Attention:  Intel License Inquiry.

from xml.dom import *
from xml.dom.minidom import *
from re import match
from sys import *
from subprocess import Popen, PIPE

# print an error message and exit
def nfail(s):
  stderr.write(s + "\n")
  exit(2)

if len(argv) == 2:
  platformdir = argv[1]
  # This gives the whole string when there's no / in platformdir
  platform = platformdir[platformdir.rfind("/") + 1:]
elif len(argv) == 1:
  platformdir = ""
  platform = ""
else:
  nfail("Usage: tos-storage-at45db <platform directory>")

sector_size = 256
flash_size = 2048 # in sectors

volumes = {}
volmap = []

def check_volume(name, base, size):
  if base == "":
    base = None
  else:
    try:
      base = int(base)
    except ValueError:
      nfail("invalid base for volume %s" % name)
    if (base & (sector_size - 1)) != 0:
      nfail("base of volume %s is not a multiple of %d" % (name, sector_size))
    base /= sector_size

  try:
    size = int(size)
  except ValueError:
    nfail("invalid size for volume %s" % name)
  if (size & (sector_size - 1)) != 0:
    nfail("size of volume %s is not a multiple of %d" % (name, sector_size))
  size /= sector_size

  name = name.upper()
  if volumes.has_key(name):
    nfail("duplicate definition of volume %s" % name)
  if not match("^[a-zA-Z0-9_]+$", name):
    nfail("invalid volume name %s" % name)
  volumes[name] = (base, size)

def allocate_at(name, base, size):
  # check for overlap of existing allocations
  for (vname, vbase, vsize) in volmap:
    if base in range(vbase, vbase + vsize) or base + size - 1 in range(vbase, vbase + vsize) or vbase in range(base, base + size) or vbase + vsize - 1 in range(base, base + size):
      nfail("volume %s overlaps volume %s" % (name, vname))

  # insert at correct position
  for i in range(len(volmap)):
    if base < volmap[i][1]:
      volmap.insert(i, (name, base, size))
      return

  # it's the last volume...
  volmap.append((name, base, size))

def allocate(name, size):
  # We just do first fit. We could spend endless effort doing better.
  base = 0
  for i in range(len(volmap)):
    (vname, vbase, vsize) = volmap[i]
    if base < vbase and size <= vbase - base:
      volmap.insert(i, (name, base, size))
      return
    base = vbase + vsize
  volmap.append((name, base, size))

def expand_path(path):
  substrs = path.split("%")
  path = substrs[0]
  i = 1
  while i < len(substrs):
    if substrs[i] == "":
      # There was a %%, leading to a blank substring, and the next string
      # should just be appended
      path += "%"
      i = i + 1
      if i < len(substrs):
        path += substrs[i]
    else:
      # The first character of the string is the one that followed %
      c = substrs[i][0]
      if c == 'p':
        sub = platform
      elif c == 'P':
        sub = platformdir
      elif c == 'T':
        sub = Popen(["ncc", "-print-tosdir"], stdout=PIPE).communicate()[0]
        sub = sub[:-1] # remove newline
      else:
        nfail("unknown include-path substitution character " + c)
      path += sub
      path += substrs[i][1:]
    i = i + 1
  return path

def volumeparse(file, fname, depth):
  if depth > 10:
    nfail("include nesting too deep - check for cycles")
  try:
    dom = parse(file)
  except xml.parsers.expat.ExpatError:
    nfail(fname + " is not a valid input file")
  except IOError:
    nfail("couldn't open file " + fname)

  for volume in dom.documentElement.getElementsByTagName("volume"):
    name = volume.getAttribute("name")
    size = volume.getAttribute("size")
    base = volume.getAttribute("base")
    if name == None:
      nfail("name omitted in volume " + fname)
    if size == None:
      nfail("size omitted in volume %s %s" % (name, fname))
    check_volume(name, base, size)
  for include in dom.documentElement.getElementsByTagName("include"):
    included = include.firstChild
    if included != None and included.nodeType == included.TEXT_NODE:
      included = expand_path(included.data)
      volumeparse(included, "(file %s)" % included, depth + 1)
    else:
      nfail("invalid include directive " + fname)
  dom.unlink()

volumeparse(stdin, "(standard input)", 0)

# allocate fixed-address volumes
for name in volumes.keys():
  (base, size) = volumes[name]
  if base != None:
    allocate_at(name, base, size)

# allocate movable volumes
for name in volumes.keys():
  (base, size) = volumes[name]
  if base == None:
    allocate(name, size)

if len(volmap) == 0:
  nfail("no volumes")

(lastname, lastbase, lastsize) = volmap[len(volmap) - 1]
if lastbase + lastsize > flash_size:
  nfail("out of space (using %d bytes, have only %d)" %
        ((lastbase + lastsize) * sector_size, flash_size * sector_size))

# print some code
print "#ifndef STORAGE_VOLUMES_H"
print "#define STORAGE_VOLUMES_H"
print
print "enum {"
for (vname, vbase, vsize) in volmap:
  print "  VOLUME_%s, " % vname
print "};"
print
print "#endif"

print "#if defined(VS)"
for (vname, vbase, vsize) in volmap:
  print "VS(VOLUME_%s, %d)" % (vname, vsize)
print "#undef VS"
print "#endif"

print "#if defined(VB)"
for (vname, vbase, vsize) in volmap:
  print "VB(VOLUME_%s, %d)" % (vname, vbase)
print "#undef VB"
print "#endif"

